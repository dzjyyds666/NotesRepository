# Java

## 1、JavaSE 和 JavaEE

JavaSE : java平台标准版,java的基础版本,包括支持Java应用程序运行和开发的核心类库和虚拟机等相关核心组件

JavaEE : java平台企业版,java的高级版本,建立在JavaSE的基础之上,还包括了支持企业级应用程序开发和部署的标准和规范.

## 2、JVM vs JDK vs JRE

**JVM** : Java虚拟机,是运行Java字节码的虚拟机,JVM针对不同操作系统有不同的实现,目的在于使用相同的字节码能够在不同的操作系统上给出相同的结果(write once,run anywhere).JVM不只有一种,只要满足JVM规范,每个人都可以开发自己的JVM,常见的JVM有HotSpot VM,J9 VM,Zing VM等等.

**JDK** : 是功能齐全的Java开发工具包,供使用者进行开发,包括JRE(Java Runtime Environment),编辑器Javac和其他工具.

**JRE** : 运行已编译Java程序所需要的环境,包括两部分:

- JVM虚拟机
- Java基础类库

简单来说,JRE包括Java程序运行所需要的环境,而JDK不仅包括JRE,还包括用于开发和调试Java程序所需要的工具.

<img src="https://oss.javaguide.cn/github/javaguide/java/basis/jdk-include-jre.png"></img>

## 3、Java和C++的区别:

- Java不提供指针直接对内存进行访问,程序内存更加方便.
- Java的类是单继承的,C++是多继承,但是Java的接口可以多继承.
- Java有自动内存管理垃圾回收机制(GC),无需程序员手动释放无用内存
- C++同时支持方法重载和操作符重载,Java只支持方法重载

## 4、移位运算

- 左移运算: 26 << 1 ,26向左移动1位,向左位移相当于乘以2的n次方,二进制形式右边补0,左边舍弃.
- 有符号右移: 正数 : 26 >> 1,26向右位移1位,相当于除以2的n次方,除的时候如果有小数位,则会舍弃小数.

​			     负数: -26 >> 1,二进制形式向右位移一位,左边补1,右边舍弃.

- 无符号右移: 二进制形式左边全部补0

移位操作只对int和long生效,编辑器对于short、byte、char类型进程操作时,编译器会将其转换为int类型.

当 int 类型左移/右移位数大于等于 32 位操作时，会先求余（%）后再进行左移/右移操作。也就是说左移/右移 32 位相当于不进行移位操作（32%32=0），左移/右移 42 位相当于左移/右移 10 位（42%32=10）。当 long 类型进行左移/右移操作时，由于 long 对应的二进制是 64 位，因此求余操作的基数也变成了 64。

## 5、Java基础数据类型

- 6种数据类型:
  - 4种整数型: `byte` 、 `short` 、 `int` 、 `long`
  - 2种浮点型:`float` 、 `double`
- 1种字符类型: char
- 1种布尔类型: boolean

| 基本类型 | 位数 | 字节 | 默认值  |                           取值范围                           |
| -------- | ---- | :--: | :-----: | :----------------------------------------------------------: |
| byte     | 8    |  1   |    0    |                          -128 ~ 127                          |
| short    | 16   |  2   |    0    |             -32768（-2^15） ~ 32767（2^15 - 1）              |
| int      | 32   |  4   |    0    |                   -2147483648 ~ 2147483647                   |
| long     | 64   |  8   |   0L    | -9223372036854775808（-2^63） ~ 9223372036854775807（2^63 -1） |
| char     | 16   |  2   | 'u0000' |                    0 ~ 65535（2^16 - 1）                     |
| float    | 32   |  4   |   0f    |                    1.4E-45 ~ 3.4028235E38                    |
| double   | 64   |  8   |   0d    |              4.9E-324 ~ 1.7976931348623157E308               |
| boolean  | 1    |      |  false  |                         true、false                          |

Java 的每种基本类型所占存储空间的大小不会像其他大多数语言那样随机器硬件架构的变化而变化。这种所占存储空间大小的不变性是 Java 程序比用其他大多数语言编写的程序更具可移植性的原因之一.

这八种基本类型都有对应的包装类分别为：`Byte`、`Short`、`Integer`、`Long`、`Float`、`Double`、`Character`、`Boolean` 。	

**基本类型和包装类型的区别？**

- **用途**：除了定义一些常量和局部变量之外，我们在其他地方比如方法参数、对象属性中很少会使用基本类型来定义变量。并且，包装类型可用于泛型，而基本类型不可以。
- **存储方式**：基本数据类型的局部变量存放在 Java 虚拟机栈中的局部变量表中，基本数据类型的成员变量（未被 `static` 修饰 ）存放在 Java 虚拟机的堆中。包装类型属于对象类型，我们知道几乎所有对象实例都存在于堆中。
- **占用空间**：相比于包装类型（对象类型）， 基本数据类型占用的空间往往非常小。
- **默认值**：成员变量包装类型不赋值就是 `null` ，而基本类型有默认值且不是 `null`。
- **比较方式**：对于基本数据类型来说，`==` 比较的是值。对于包装数据类型来说，`==` 比较的是对象的内存地址。所有整型包装类对象之间值的比较，全部使用 `equals()` 方法。

**包装类型的缓存机制了解么？**

Java 基本数据类型的包装类型的大部分都用到了缓存机制来提升性能。

`Byte`,`Short`,`Integer`,`Long` 这 4 种包装类默认创建了数值 **[-128，127]** 的相应类型的缓存数据，`Character` 创建了数值在 **[0,127]** 范围的缓存数据，`Boolean` 直接返回 `True` or `False`。

```java
Integer i1 = 40;
Integer i2 = new Integer(40);
System.out.println(i1==i2);
```

`Integer i1=40` 这一行代码会发生装箱，也就是说这行代码等价于 `Integer i1=Integer.valueOf(40)` 。因此，`i1`直接使用的是缓存中的对象。而`Integer i2 = new Integer(40)` 会直接创建新的对象。所以答案是`false`.

### 重载和重写有什么区别?	

> 重载就是同样的一个方法能够根据输入数据的不同，做出不同的处理
>
> 重写就是当子类继承自父类的相同方法，输入数据一样，但要做出有别于父类的响应时，你就要覆盖父类方法

**方法的重写要遵循“两同两小一大”**:

“两同”即方法名相同、形参列表相同；

“两小”指的是子类方法返回值类型应比父类方法返回值类型更小或相等，子类方法声明抛出的异常类应比父类方法声明抛出的异常类更小或相等；

“一大”指的是子类方法的访问权限应比父类方法的访问权限更大或相等。
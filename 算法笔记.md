# 算法笔记

摘自:[leetcode最强刷题指南](https://blog.csdn.net/sinat_16643223/article/details/114152438)

## 一、了解算法复杂度

- 时间复杂度:[算法时间复杂度详解](https://mp.weixin.qq.com/s?__biz=MzUxNjY5NTYxNA==&mid=2247485980&idx=1&sn=88a44d270b1361611996281446c4f7b6&scene=21#wechat_redirect)

- 空间复杂度:表示一个算法在运行过程中临时占用存储空间大小的量度

## 二、基本数据结构

### 1、数组

数组是存放在连续空间上的相同数据类型数据的集合

> 要点:
>
> - 数组的下标都是从0开始
> - 数组在内存中是一片连续的地址空间
> - 二维数组是一个线性数组,数组中存放的是每一行数据的首地址

#### 算法详解:二分法

##### 例题:35.[搜索插入位置](https://leetcode.cn/problems/search-insert-position/)

> 给定一个排序数组和一个目标值，在数组中找到目标值，并返回其索引。如果目标值不存在于数组中，返回它将会被按顺序插入的位置。
>
> 请必须使用时间复杂度为 `O(log n)` 的算法。
>
> **示例 1:**
>
> ```
>输入: nums = [1,3,5,6], target = 5
> 输出: 2
> ```
> 
> **示例 2:**
>
> ```
>输入: nums = [1,3,5,6], target = 2
> 输出: 1
> ```
> 
> **示例 3:**
>
> ```
>输入: nums = [1,3,5,6], target = 7
> 输出: 4
> ```

思路:可以使用两种办法,暴力搜索和二分查找法,使用二分查找法需要注意选择的区间问题,如果选择的是**左闭右闭**,则**while(left <= right)**,如果选择的是**左闭右开**,则**while(left < right)**.

> - 暴力破解

```java
class Solution {
  	public int searchInsert(int nums[],int target){
      int length = nums.length;
     	for(int i = 0;i < length;i++){
        // 从0开始遍历数组,数组元素小于目标元素,直接跳过,数组元素大于或等于目标元素,则直接返回数组元素的下标
        if(target <= nums[i]){
          	return i;
        }
      }
      // 目标元素大于数组中的所有元素,则要插入数组后面
      return length + 1;
    }
}
```

> - 二分查找第一种(左闭右闭)

```java
class Solution {
  public int searchInsert(int nums[],int target){
    int length = nums.length;
    int left = 0;
    int right = length - 1; // 左闭右闭
    while(left <= right){
      int middle = left + (right - left) / 2;
      if(target > nums[middle]){
        // 目标元素在右区间
        left = middle + 1;
      }else if(target < nums[middle]){
        // 目标在左区间
        right = middle - 1;
      }else if(target == nums[middle]){
        return middle;
      }
    }
    // 分别处理如下四种情况
    // 目标值在数组所有元素之前  [0, -1]
    // 目标值等于数组中某一个元素  return middle;
    // 目标值插入数组中的位置 [left, right]，return  right + 1
    // 目标值在数组所有元素之后的情况 [left, right]， return right + 1
    return right + 1;
  }
}
```

> - 二分查找第二种(左闭右开)

```java
class Solution {
  public int searchInsert(int nums[],int target){
    int length = nums.length;
    int left = 0;
    int right = length; // 左闭右开
    while(left < right){
      int middle = left + (right - left) / 2;
      if(target > nums[middle]){
        // 目标元素在右区间
        left = middle + 1;
      }else if(target < nums[middle]){
        // 目标在左区间
        right = middle ;
      }else if(target == nums[middle]){
        return middle ;
      }
    }
    // 分别处理如下四种情况
    // 目标值在数组所有元素之前 [0,0)
    // 目标值等于数组中某一个元素 return middle
    // 目标值插入数组中的位置 [left, right) ，return right 即可
    // 目标值在数组所有元素之后的情况 [left, right)，return right 即可
    return right ;
  }
}
```

##### 34.[在排序数组中查找元素的第一个和最后一个位置](https://programmercarl.com/0034.在排序数组中查找元素的第一个和最后一个位置.html)

##### 69.[x 的平方根](https://leetcode.cn/problems/sqrtx/)

##### 367.[有效的完全平方数](https://leetcode.cn/problems/valid-perfect-square/)

#### 算法详解:快慢指针

##### 例题:27.[移除指针](https://leetcode.cn/problems/remove-element/description/)

> 给你一个数组 nums 和一个值 val，你需要 原地 移除所有数值等于 val 的元素，并返回移除后数组的新长度。
>
> 不要使用额外的数组空间，你必须仅使用 O(1) 额外空间并**原地**修改输入数组。元素的顺序可以改变。
>
> 你不需要考虑数组中超出新长度后面的元素。
>
> **示例1:**
>
> ```
> 输入：nums = [3,2,2,3], val = 3
> 输出：2, nums = [2,2,_,_]
> 解释：你的函数函数应该返回 k = 2, 并且 nums 中的前两个元素均为 2。
> 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
> ```
>
> **示例2:**
>
> ```
> 输入：nums = [0,1,2,2,3,0,4,2], val = 2
> 输出：5, nums = [0,1,4,0,3,_,_,_]
> 解释：你的函数应该返回 k = 5，并且 nums 中的前五个元素为 0,0,1,3,4。
> 注意这五个元素可以任意顺序返回。
> 你在返回的 k 个元素之外留下了什么并不重要（因此它们并不计入评测）。
> ```

思路:这道题可以使用暴力破解方法,采用双层for循环循环数组,第一层循环用于查找是否存在**val**,第二层循环用于覆盖元素,但是这种方法的算法复杂度在O(n^2).第二种方法是采用快慢指针法,定义一个快指针,一个慢指针,两个指针同时向后移动,对快指针指定的数组元素与val进行比较,如果**nums[fast] != val**,则快指针和慢指针同时加一,并且互换所指定的元素,如果**nums[fast] = val**,则只fast++,直到fast == nums.length,返回slow即可.

```java
class Solution {
    public int removeElement(int[] nums, int val) {
        int fast = 0,slow = 0;
        while(fast < nums.length){
            if(nums[fast] != val){
                int temp = nums[fast];
                nums[fast] = nums[slow];
                nums[slow] = temp;
                fast++;
                slow++;
            }else{
                fast++;
            }
        }
        return slow;
    }
}
```

##### 例题:26.[删除有序数组的重复项](https://leetcode.cn/problems/remove-duplicates-from-sorted-array/description/)

> 给你一个 **非严格递增排列** 的数组 `nums` ，请你**[ 原地](http://baike.baidu.com/item/原地算法)** 删除重复出现的元素，使每个元素 **只出现一次** ，返回删除后数组的新长度。元素的 **相对顺序** 应该保持 **一致** 。然后返回 `nums` 中唯一元素的个数。
>
> 考虑 `nums` 的唯一元素的数量为 `k` ，你需要做以下事情确保你的题解可以被通过：
>
> - 更改数组 `nums` ，使 `nums` 的前 `k` 个元素包含唯一元素，并按照它们最初在 `nums` 中出现的顺序排列。`nums` 的其余元素与 `nums` 的大小不重要。
> - 返回 `k` 。
>
> **示例1:**
>
> ```
> 输入：nums = [1,1,2]
> 输出：2, nums = [1,2,_]
> 解释：函数应该返回新的长度 2 ，并且原数组 nums 的前两个元素被修改为 1, 2 。不需要考虑数组中超出新长度后面的元素。
> ```
>
> **示例2:**
>
> ```
> 输入：nums = [0,0,1,1,1,2,2,3,3,4]
> 输出：5, nums = [0,1,2,3,4]
> 解释：函数应该返回新的长度 5 ， 并且原数组 nums 的前五个元素被修改为 0, 1, 2, 3, 4 。不需要考虑数组中超出新长度后面的元素。
> ```

思路:使用快慢指针十分简单的解决该问题,思路与上道题一致,定义fast,slow指针,同时指向数组0号位,开始循环,如果nums[fast] == nums[slow],则fast++,反之,先slow++,然后置换fast和slow指定的元素,最后在fast++,直到fast == nums.length,返回slow+1.

```java
class Solution {
    public int removeDuplicates(int[] nums) {
        int fast = 0,slow = 0;
        while(fast < nums.length){
            if(nums[fast] == nums[slow]){
                fast++;
            }else{
                slow++;
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                fast++;
            }
        }
        return slow + 1;
    }
}
```

##### 例题:283.[移动零](https://leetcode.cn/problems/move-zeroes/)

> 给定一个数组 `nums`，编写一个函数将所有 `0` 移动到数组的末尾，同时保持非零元素的相对顺序。
>
> **请注意** ，必须在不复制数组的情况下原地对数组进行操作。
>
> **示例1:**
>
> ```
> 输入: nums = [0,1,0,3,12]
> 输出: [1,3,12,0,0]
> ```
>
> **示例2:**
>
> ```
> 输入: nums = [0]
> 输出: [0]
> ```

思路:采用快慢指针法.

```java
class Solution {
    public void moveZeroes(int[] nums) {
        int fast = 0 ,slow = 0;
        while(fast < nums.length){
            if(nums[fast] == 0){
                fast++;
            }else{
                int temp = nums[slow];
                nums[slow] = nums[fast];
                nums[fast] = temp;
                slow++;
                fast++;
            }
        }
    }
}
```

##### 844.[比较含退格的字符串](https://leetcode.cn/problems/backspace-string-compare/)

##### 977.[有序数组的平方(opens new window)](https://leetcode.cn/problems/squares-of-a-sorted-array/)

